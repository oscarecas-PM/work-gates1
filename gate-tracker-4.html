<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gate Tracker</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: Arial, sans-serif; padding: 1.5rem; background: #f5f5f5; color: #222; }
  h1 { margin-bottom: 0.5rem; }
  .description { color: #555; margin-bottom: 1.5rem; }

  .file-inputs { display: flex; gap: 2rem; flex-wrap: wrap; margin-bottom: 1rem; }
  .file-group { background: #fff; border: 1px solid #ccc; border-radius: 6px; padding: 1rem; min-width: 280px; }
  .file-group h3 { margin-bottom: 0.5rem; }
  .file-group p { font-size: 0.85rem; color: #666; margin-bottom: 0.5rem; }
  .status { font-size: 0.85rem; margin-top: 0.5rem; }
  .status.loaded { color: green; }
  .status.error { color: red; }

  #run-btn { margin: 1rem 0; padding: 10px 24px; font-size: 1rem; cursor: pointer; background: #2563eb; color: #fff; border: none; border-radius: 4px; }
  #run-btn:disabled { background: #aaa; cursor: default; }
  #run-btn:hover:not(:disabled) { background: #1d4ed8; }

  /* Print / PDF button */
  #print-btn { margin: 1rem 0 1rem 12px; padding: 10px 24px; font-size: 1rem; cursor: pointer; background: #334155; color: #fff; border: none; border-radius: 4px; display: none; }
  #print-btn:hover { background: #1e293b; }

  /* Filter bars */
  .filter-bar { margin-bottom: 0.75rem; padding: 10px 14px; background: #fff; border: 1px solid #ccc; border-radius: 6px; display: none; }
  .filter-bar .filter-title { font-weight: bold; font-size: 0.85rem; margin-bottom: 6px; color: #555; }
  .filter-bar .filter-chips { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }
  .filter-chip { display: inline-flex; align-items: center; padding: 4px 12px; border-radius: 4px; font-size: 0.82rem; cursor: pointer; border: 1px solid #cbd5e1; background: #fff; color: #334155; user-select: none; transition: all 0.15s; }
  .filter-chip.selected { background: #2563eb; color: #fff; border-color: #2563eb; }
  .filter-chip:hover { border-color: #2563eb; }
  .filter-chip.pn-chip.selected { background: #1e3a5f; border-color: #1e3a5f; }
  .filter-chip.pn-chip:hover { border-color: #1e3a5f; }

  /* Program sections */
  .program-section { margin-top: 2rem; }
  .program-heading { font-size: 1.3rem; font-weight: bold; color: #111; margin-bottom: 0.5rem; border-bottom: 2px solid #334155; padding-bottom: 4px; }

  /* Part No. sections */
  .part-section { margin-top: 1rem; margin-bottom: 1.5rem; }
  .part-header { background: #1e3a5f; color: #fff; padding: 8px 14px; border-radius: 4px 4px 0 0; font-size: 1.1rem; font-weight: bold; }

  /* Order cards */
  .order-card { background: #fff; border: 1px solid #ccc; border-top: none; }
  .order-card:last-child { border-radius: 0 0 4px 4px; }
  .order-row { display: flex; align-items: stretch; min-height: 48px; }

  /* Left: order info — fixed width */
  .order-info { flex: 0 0 280px; width: 280px; display: flex; align-items: center; gap: 1rem; padding: 6px 14px; background: #e2e8f0; border-right: 1px solid #ccc; }
  .order-info .field { white-space: nowrap; }
  .order-info .label { font-weight: bold; color: #555; font-size: 0.75rem; }
  .order-info .value { color: #111; font-size: 0.85rem; }
  .hold-flag { color: #b91c1c; font-weight: bold; font-size: 0.8rem; }

  /* Right: gate bar */
  .gate-bar { display: flex; flex: 1; overflow-x: auto; align-items: stretch; }
  .gate-col { flex: 1; min-width: 70px; text-align: center; border-right: 1px solid #eee; display: flex; flex-direction: column; }
  .gate-col:last-child { border-right: none; }
  .gate-name { background: #334155; color: #fff; font-size: 0.7rem; font-weight: bold; padding: 2px 4px; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; height: 3.6em; display: flex; align-items: center; justify-content: center; text-align: center; line-height: 1.2; overflow: hidden; }
  .gate-name.blank { background: #94a3b8; }
  .gate-opers { padding: 4px 3px; font-size: 0.78rem; display: flex; flex-wrap: wrap; justify-content: center; gap: 3px; align-items: center; flex: 1; }

  /* Oper chips */
  .oper-chip { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.75rem; cursor: default; }
  .oper-chip.active-green { background: #16a34a; color: #fff; font-weight: bold; }
  .oper-chip.active-yellow { background: #ca8a04; color: #fff; font-weight: bold; }
  .oper-chip.active-blue { background: #2563eb; color: #fff; font-weight: bold; }
  .oper-chip.active-pink { background: #db2777; color: #fff; font-weight: bold; }
  .oper-chip.inactive { background: #e5e7eb; color: #aaa; }
  .oper-chip[title] { cursor: pointer; }

  /* Print timestamp */
  #print-timestamp { display: none; font-size: 0.85rem; color: #555; margin-bottom: 0.5rem; }

  /* Gate View */
  .gate-view-wrapper { border-top: 3px solid #334155; margin-top: 2.5rem; padding-top: 1.5rem; }
  .gate-view-title { font-size: 1.4rem; font-weight: bold; color: #111; margin-bottom: 1rem; }
  .gv-gate-section { margin-bottom: 1.5rem; }
  .gv-gate-header { background: #334155; color: #fff; padding: 8px 14px; border-radius: 4px 4px 0 0; font-size: 1rem; font-weight: bold; }
  .gv-gate-header.hold-gate { background: #991b1b; }
  .gv-cards-row { display: flex; flex-wrap: wrap; gap: 8px; padding: 10px; background: #fff; border: 1px solid #ccc; border-top: none; border-radius: 0 0 4px 4px; }
  .gv-order-card { min-width: 130px; max-width: 180px; padding: 8px 10px; border-radius: 4px; border: 2px solid transparent; cursor: default; font-size: 0.82rem; }
  .gv-order-no { font-weight: bold; font-size: 0.85rem; }
  .gv-part-no { font-size: 0.78rem; color: rgba(0,0,0,0.7); }
  .gv-sn { font-size: 0.75rem; color: rgba(0,0,0,0.55); }
  .gv-hold { color: #b91c1c; font-weight: bold; font-size: 0.75rem; }
  .gv-days { font-size: 0.72rem; color: rgba(0,0,0,0.5); margin-top: 2px; }

  /* Print styles */
  @media print {
    body { background: #fff; padding: 0.5rem; }
    .file-inputs, #run-btn, #print-btn, .filter-bar, .description { display: none !important; }
    #print-timestamp { display: block !important; }
    .program-section { break-inside: avoid; }
    .part-section { break-inside: avoid; }
    .order-card { break-inside: avoid; }
    .gate-view-wrapper { break-before: page; }
    .gv-gate-section { break-inside: avoid; }
  }
</style>
</head>
<body>

<h1>Gate Tracker</h1>
<p class="description">Load the Gate Decoder Ring and Daily Upload CSV files, then click Process.</p>

<div class="file-inputs">
  <div class="file-group">
    <h3>1. Gate Decoder Ring</h3>
    <p>Columns: Part No., Part Name, Gate Number, Gate Name, Oper No., Work Dept, Modifier</p>
    <input type="file" id="decoder-input" accept=".csv">
    <div id="decoder-status" class="status"></div>
  </div>
  <div class="file-group">
    <h3>2. Daily Upload</h3>
    <p>Columns: Order No., Oper No., Oper Title, Oper Status, Part No., Program, Serial No, Order Hold Status, ...</p>
    <input type="file" id="daily-input" accept=".csv">
    <div id="daily-status" class="status"></div>
  </div>
</div>

<button id="run-btn" disabled onclick="process()">Process</button>
<button id="print-btn" onclick="printPage()">Print / Export PDF</button>

<div id="print-timestamp"></div>

<div id="program-filter" class="filter-bar">
  <div class="filter-title">Programs</div>
  <div class="filter-chips" id="pgm-filter-chips"></div>
</div>
<div id="part-filter" class="filter-bar">
  <div class="filter-title">Part Numbers</div>
  <div class="filter-chips" id="pn-filter-chips"></div>
</div>
<div id="output"></div>

<script>
let decoderData = null;
let dailyData = null;

document.getElementById('decoder-input').addEventListener('change', function(e) {
  loadCSV(e.target.files[0], function(rows) {
    decoderData = rows;
    showStatus('decoder-status', 'Loaded ' + (rows.length - 1) + ' rows', false);
    checkReady();
  }, 'decoder-status');
});

document.getElementById('daily-input').addEventListener('change', function(e) {
  loadCSV(e.target.files[0], function(rows) {
    dailyData = rows;
    showStatus('daily-status', 'Loaded ' + (rows.length - 1) + ' rows', false);
    checkReady();
  }, 'daily-status');
});

function checkReady() {
  document.getElementById('run-btn').disabled = !(decoderData && dailyData);
}

function showStatus(id, msg, isError) {
  const el = document.getElementById(id);
  el.textContent = msg;
  el.className = 'status ' + (isError ? 'error' : 'loaded');
}

function loadCSV(file, callback, statusId) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    try {
      const rows = parseCSV(ev.target.result);
      if (rows.length < 2) throw new Error('File has no data rows');
      callback(rows);
    } catch (err) {
      showStatus(statusId, 'Error: ' + err.message, true);
    }
  };
  reader.readAsText(file);
}

function parseCSV(text) {
  const result = [];
  let current = '';
  let inQuotes = false;
  let row = [];
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (inQuotes) {
      if (ch === '"' && text[i + 1] === '"') { current += '"'; i++; }
      else if (ch === '"') { inQuotes = false; }
      else { current += ch; }
    } else {
      if (ch === '"') { inQuotes = true; }
      else if (ch === ',') { row.push(current.trim()); current = ''; }
      else if (ch === '\n' || (ch === '\r' && text[i + 1] === '\n')) {
        row.push(current.trim()); current = '';
        if (row.length > 1 || row[0] !== '') result.push(row);
        row = [];
        if (ch === '\r') i++;
      } else { current += ch; }
    }
  }
  row.push(current.trim());
  if (row.length > 1 || row[0] !== '') result.push(row);
  return result;
}

function colIndex(headers, name) {
  const n = name.toLowerCase().trim();
  for (let i = 0; i < headers.length; i++) {
    if (headers[i].toLowerCase().trim() === n) return i;
  }
  return -1;
}

// --- Globals for filters ---
let allPrograms = [];
let selectedPrograms = new Set();
let allPartNos = [];
let selectedPartNo = null; // null = show all

function toggleProgram(pgm) {
  if (selectedPrograms.has(pgm)) {
    selectedPrograms.delete(pgm);
  } else {
    selectedPrograms.add(pgm);
  }
  applyFilters();
}

function selectAllPrograms() {
  selectedPrograms = new Set(allPrograms);
  applyFilters();
}

function selectPartNo(pn) {
  if (selectedPartNo === pn) {
    selectedPartNo = null; // deselect = show all
  } else {
    selectedPartNo = pn;
  }
  applyFilters();
}

function showAllParts() {
  selectedPartNo = null;
  applyFilters();
}

function applyFilters() {
  // Program chips
  document.querySelectorAll('.filter-chip[data-pgm]').forEach(c => {
    c.classList.toggle('selected', selectedPrograms.has(c.dataset.pgm));
  });
  // Part No. chips
  document.querySelectorAll('.filter-chip[data-pn]').forEach(c => {
    c.classList.toggle('selected', selectedPartNo === null ? false : c.dataset.pn === selectedPartNo);
  });
  // "Show All" for parts
  const pnAllBtn = document.getElementById('pn-show-all');
  if (pnAllBtn) pnAllBtn.classList.toggle('selected', selectedPartNo === null);

  // Visibility: program sections
  document.querySelectorAll('.program-section').forEach(s => {
    s.style.display = selectedPrograms.has(s.dataset.program) ? '' : 'none';
  });
  // Visibility: part sections
  document.querySelectorAll('.part-section').forEach(s => {
    if (selectedPartNo === null) {
      s.style.display = '';
    } else {
      s.style.display = s.dataset.partno === selectedPartNo ? '' : 'none';
    }
  });
}

function printPage() {
  const ts = document.getElementById('print-timestamp');
  const now = new Date();
  ts.textContent = 'Exported: ' + now.toLocaleDateString() + ' ' + now.toLocaleTimeString();
  ts.style.display = 'block';
  setTimeout(function() { window.print(); }, 100);
}

function process() {
  const output = document.getElementById('output');
  const pgmFilterEl = document.getElementById('program-filter');
  const pgmFilterChips = document.getElementById('pgm-filter-chips');
  const pnFilterEl = document.getElementById('part-filter');
  const pnFilterChips = document.getElementById('pn-filter-chips');
  const printBtn = document.getElementById('print-btn');
  output.innerHTML = '';
  pgmFilterEl.style.display = 'none';
  pgmFilterChips.innerHTML = '';
  pnFilterEl.style.display = 'none';
  pnFilterChips.innerHTML = '';
  printBtn.style.display = 'none';

  // ---- Decoder Ring ----
  const dHeaders = decoderData[0];
  const dPartIdx = colIndex(dHeaders, 'Part No.');
  const dGateNumIdx = colIndex(dHeaders, 'Gate Number');
  const dGateNameIdx = colIndex(dHeaders, 'Gate Name');
  const dOperIdx = colIndex(dHeaders, 'Oper No.');

  if (dPartIdx < 0 || dGateNumIdx < 0 || dGateNameIdx < 0 || dOperIdx < 0) {
    output.innerHTML = '<p style="color:red;">Error: Decoder Ring CSV missing required columns (Part No., Gate Number, Gate Name, Oper No.)</p>';
    return;
  }

  const gateLookup = {};
  const gatesByPart = {};
  const decoderParts = new Set();
  const partNames = {};
  const modifierByOper = {};
  const dPartNameIdx = colIndex(dHeaders, 'Part Name');
  const dModifierIdx = colIndex(dHeaders, 'Modifier');

  for (let i = 1; i < decoderData.length; i++) {
    const r = decoderData[i];
    const partNo = (r[dPartIdx] || '').trim();
    const gateNum = (r[dGateNumIdx] || '').trim();
    const gateName = (r[dGateNameIdx] || '').trim();
    const operNo = (r[dOperIdx] || '').trim();
    if (!partNo) continue;
    decoderParts.add(partNo);
    if (dPartNameIdx >= 0 && !partNames[partNo]) {
      partNames[partNo] = (r[dPartNameIdx] || '').trim();
    }
    gateLookup[partNo + '|||' + normOper(operNo)] = { gateNumber: gateNum, gateName: gateName };
    if (dModifierIdx >= 0) { modifierByOper[partNo + '|||' + normOper(operNo)] = (r[dModifierIdx] || '').trim().toLowerCase(); }

    if (!gatesByPart[partNo]) gatesByPart[partNo] = [];
    const gateArr = gatesByPart[partNo];
    const gateKey = gateNum + '|||' + gateName;
    const last = gateArr.length > 0 ? gateArr[gateArr.length - 1] : null;
    const lastKey = last ? (last.gateNumber + '|||' + last.gateName) : null;
    if (lastKey === gateKey) {
      last.opers.push(operNo);
    } else {
      gateArr.push({ gateNumber: gateNum, gateName: gateName, opers: [operNo] });
    }
  }

  // ---- Daily Upload ----
  const uHeaders = dailyData[0];
  const uOrderIdx = colIndex(uHeaders, 'Order No.');
  const uOperStatusIdx = colIndex(uHeaders, 'Oper Status');
  const uOperNoIdx = colIndex(uHeaders, 'Oper No.');
  const uOperTitleIdx = colIndex(uHeaders, 'Oper Title');
  const uPartIdx = colIndex(uHeaders, 'Part No.');
  const uProgramIdx = colIndex(uHeaders, 'Program');
  const uSerialIdx = colIndex(uHeaders, 'Serial No');
  const uOrderHoldIdx = colIndex(uHeaders, 'Order Hold Status');
  const uTotalDaysIdx = colIndex(uHeaders, 'Total Days at Operation');
  const uWorkDeptIdx = colIndex(uHeaders, 'Work Dept');

  const missingCols = [];
  if (uOrderIdx < 0) missingCols.push('Order No.');
  if (uOperStatusIdx < 0) missingCols.push('Oper Status');
  if (uOperNoIdx < 0) missingCols.push('Oper No.');
  if (uOperTitleIdx < 0) missingCols.push('Oper Title');
  if (uPartIdx < 0) missingCols.push('Part No.');
  if (uProgramIdx < 0) missingCols.push('Program');
  if (uSerialIdx < 0) missingCols.push('Serial No');
  if (uOrderHoldIdx < 0) missingCols.push('Order Hold Status');

  if (missingCols.length > 0) {
    output.innerHTML = '<p style="color:red;">Error: Daily Upload CSV missing columns: ' + missingCols.join(', ') + '</p>';
    return;
  }

  // Row count warning (>500 rows)
  const dailyRowCount = dailyData.length - 1;
  if (dailyRowCount > 500) {
    if (!confirm('Warning: The Daily Upload contains ' + dailyRowCount + ' rows, which exceeds the typical 500-row threshold. Processing may be slow.\n\nContinue?')) {
      return;
    }
  }

  // Group: program -> partNo -> orderNo -> [rows]
  const byProg = {};
  const partNoSet = new Set();
  for (let i = 1; i < dailyData.length; i++) {
    const r = dailyData[i];
    const partNo = (r[uPartIdx] || '').trim();
    if (!decoderParts.has(partNo)) continue;
    const program = (r[uProgramIdx] || '').trim() || '(No Program)';
    const orderNo = (r[uOrderIdx] || '').trim();

    if (!byProg[program]) byProg[program] = {};
    if (!byProg[program][partNo]) byProg[program][partNo] = {};
    if (!byProg[program][partNo][orderNo]) byProg[program][partNo][orderNo] = [];

    byProg[program][partNo][orderNo].push({
      partNo: partNo,
      serialNo: (r[uSerialIdx] || '').trim(),
      orderNo: orderNo,
      operNo: (r[uOperNoIdx] || '').trim(),
      operTitle: (r[uOperTitleIdx] || '').trim(),
      operStatus: (r[uOperStatusIdx] || '').trim(),
      orderHoldStatus: (r[uOrderHoldIdx] || '').trim(),
      totalDays: uTotalDaysIdx >= 0 ? (r[uTotalDaysIdx] || '').trim() : '',
      workDept: uWorkDeptIdx >= 0 ? (r[uWorkDeptIdx] || '').trim() : ''
    });
    partNoSet.add(partNo);
  }

  allPrograms = Object.keys(byProg).sort();

  // Program color map for Gate View
  const programColors = [
    { bg: '#dbeafe', border: '#3b82f6' },
    { bg: '#fef3c7', border: '#f59e0b' },
    { bg: '#dcfce7', border: '#22c55e' },
    { bg: '#fce7f3', border: '#ec4899' }
  ];
  const programColorMap = {};
  allPrograms.forEach(function(pgm, idx) {
    programColorMap[pgm] = programColors[idx % programColors.length];
  });
  selectedPrograms = new Set(allPrograms);
  allPartNos = Array.from(partNoSet).sort();
  selectedPartNo = null;

  // ---- Program filter chips ----
  if (allPrograms.length > 0) {
    pgmFilterEl.style.display = 'block';
    const allBtn = document.createElement('span');
    allBtn.className = 'filter-chip selected';
    allBtn.textContent = 'Show All';
    allBtn.style.fontWeight = 'bold';
    allBtn.addEventListener('click', selectAllPrograms);
    pgmFilterChips.appendChild(allBtn);

    for (const pgm of allPrograms) {
      const chip = document.createElement('span');
      chip.className = 'filter-chip selected';
      chip.textContent = pgm;
      chip.dataset.pgm = pgm;
      chip.addEventListener('click', function() { toggleProgram(pgm); });
      pgmFilterChips.appendChild(chip);
    }
  }

  // ---- Part No. filter chips ----
  if (allPartNos.length > 0) {
    pnFilterEl.style.display = 'block';
    const pnAllBtn = document.createElement('span');
    pnAllBtn.className = 'filter-chip pn-chip selected';
    pnAllBtn.id = 'pn-show-all';
    pnAllBtn.textContent = 'Show All';
    pnAllBtn.style.fontWeight = 'bold';
    pnAllBtn.addEventListener('click', showAllParts);
    pnFilterChips.appendChild(pnAllBtn);

    for (const pn of allPartNos) {
      const chip = document.createElement('span');
      chip.className = 'filter-chip pn-chip';
      const pName = partNames[pn];
      chip.textContent = pn + (pName ? ' — ' + pName : '');
      chip.dataset.pn = pn;
      chip.addEventListener('click', function() { selectPartNo(pn); });
      pnFilterChips.appendChild(chip);
    }
  }

  // Show print button
  printBtn.style.display = 'inline-block';

  // ---- Render: Program -> Part No. -> Order No. ----
  for (const program of allPrograms) {
    const progSection = document.createElement('div');
    progSection.className = 'program-section';
    progSection.dataset.program = program;

    const progHeading = document.createElement('div');
    progHeading.className = 'program-heading';
    progHeading.textContent = program;
    progSection.appendChild(progHeading);

    const partsInProg = Object.keys(byProg[program]).sort();

    for (const partNo of partsInProg) {
      const section = document.createElement('div');
      section.className = 'part-section';
      section.dataset.partno = partNo;

      const partHeader = document.createElement('div');
      partHeader.className = 'part-header';
      const pName = partNames[partNo];
      partHeader.textContent = partNo + (pName ? ' \u2014 ' + pName : '');
      section.appendChild(partHeader);

      const gates = gatesByPart[partNo] || [];
      const sortedOrderNos = Object.keys(byProg[program][partNo]).sort();

      for (const orderNo of sortedOrderNos) {
        const rows = byProg[program][partNo][orderNo];

        const operInfo = {};
        for (const r of rows) {
          operInfo[normOper(r.operNo)] = { operTitle: r.operTitle, operStatus: r.operStatus, rawOperNo: r.operNo, totalDays: r.totalDays, workDept: r.workDept };
        }
        const activeOpers = new Set(Object.keys(operInfo));

        // Separate undefined opers into DR Ops (7000-7999) vs other
        const drOps = [];
        const otherUndefined = [];
        for (const nOp of activeOpers) {
          if (!gateLookup[partNo + '|||' + nOp]) {
            const raw = operInfo[nOp].rawOperNo;
            const num = parseFloat(nOp) || 0;
            if (num >= 7000 && num <= 7999) {
              drOps.push(raw);
            } else {
              otherUndefined.push({ raw: raw, num: num });
            }
          }
        }

        // Gates in CSV order
        const columns = [];
        for (const gate of gates) {
          const minOp = Math.min(...gate.opers.map(o => parseFloat(o) || 0));
          const label = gate.gateNumber + '. ' + gate.gateName;
          columns.push({ gateLabel: label, opers: gate.opers, minOp: minOp });
        }

        // Insert non-DR undefined opers chronologically among gates
        otherUndefined.sort((a, b) => a.num - b.num);
        for (const uOp of otherUndefined) {
          let insertIdx = columns.length;
          for (let i = 0; i < columns.length; i++) {
            if (columns[i].minOp > uOp.num) { insertIdx = i; break; }
          }
          columns.splice(insertIdx, 0, { gateLabel: '', opers: [uOp.raw], minOp: uOp.num });
        }

        // DR Ops (7000-7999) collected into one column at the far right
        if (drOps.length > 0) {
          drOps.sort((a, b) => (parseFloat(a) || 0) - (parseFloat(b) || 0));
          columns.push({ gateLabel: 'DR Ops', opers: drOps, minOp: 99999 });
        }

        const card = document.createElement('div');
        card.className = 'order-card';

        const firstRow = rows[0];
        let html = '<div class="order-row">';

        // Order info — fixed width, hold status without label, truncated to 12 chars
        html += '<div class="order-info">';
        html += '<div class="field"><span class="label">Order </span><span class="value">' + esc(orderNo) + '</span></div>';
        html += '<div class="field"><span class="label">S/N </span><span class="value">' + esc(firstRow.serialNo) + '</span></div>';
        const holdText = firstRow.orderHoldStatus ? firstRow.orderHoldStatus.substring(0, 12) : '';
        if (holdText) {
          html += '<div class="field"><span class="hold-flag">' + esc(holdText) + '</span></div>';
        }
        html += '</div>';

        html += '<div class="gate-bar">';
        for (const col of columns) {
          html += '<div class="gate-col">';
          html += '<div class="gate-name' + (col.gateLabel === '' ? ' blank' : '') + '">' + (col.gateLabel ? esc(col.gateLabel) : '&nbsp;') + '</div>';
          html += '<div class="gate-opers">';
          for (const op of col.opers) {
            const nOp = normOper(op);
            const isActive = activeOpers.has(nOp);
            const info = operInfo[nOp];
            const deptUpper = info ? (info.workDept || '').toUpperCase().trim() : '';
            const showDept = info && info.workDept && deptUpper !== 'SMART';
            const tooltip = info ? esc(info.operTitle) + ' \u2014 ' + esc(info.operStatus) + (showDept ? ' \u2014 ' + esc(info.workDept) : '') + (info.totalDays ? ' \u2014 ' + esc(info.totalDays) + ' days' : '') : '';
            if (isActive) {
              // Determine color class based on Oper Status + Work Dept
              const status = (info.operStatus || '').toUpperCase().trim();
              const dept = (info.workDept || '').toUpperCase().trim();
              let colorClass;
              if (status === 'IN QUEUE') {
                colorClass = 'active-yellow';
              } else if (status === 'ACTIVE') {
                if (dept.endsWith('_QA')) {
                  colorClass = 'active-blue';
                } else if (dept === 'SMART') {
                  colorClass = 'active-green';
                } else {
                  colorClass = 'active-pink';
                }
              } else {
                // Any other status (CLOSED, COMPLETE, etc.) = grey with tooltip
                colorClass = 'inactive';
              }
              html += '<span class="oper-chip ' + colorClass + '" title="' + tooltip + '">' + esc(op) + '</span>';
            } else {
              html += '<span class="oper-chip inactive">' + esc(op) + '</span>';
            }
          }
          html += '</div></div>';
        }
        html += '</div></div>';

        card.innerHTML = html;
        section.appendChild(card);
      }

      progSection.appendChild(section);
    }

    output.appendChild(progSection);
  }

  // ==== GATE VIEW: Placement Algorithm ====
  const HOLD_KEY = 'HOLD';
  const gateViewBuckets = {};
  const placedOrders = new Set();

  for (const program of allPrograms) {
    for (const partNo of Object.keys(byProg[program])) {
      for (const orderNo of Object.keys(byProg[program][partNo])) {
        if (placedOrders.has(orderNo)) continue;
        placedOrders.add(orderNo);

        const rows = byProg[program][partNo][orderNo];
        const firstRow = rows[0];
        const holdStatus = (firstRow.orderHoldStatus || '').trim();
        const holdUpper = holdStatus.toUpperCase();

        // Collect active/in-queue operations
        const activeOps = [];
        let maxDays = 0;
        for (const r of rows) {
          const st = (r.operStatus || '').toUpperCase().trim();
          if (st === 'ACTIVE' || st === 'IN QUEUE') {
            const days = parseFloat(r.totalDays) || 0;
            activeOps.push({ operNo: r.operNo, operTitle: r.operTitle, operStatus: r.operStatus, workDept: r.workDept, totalDays: r.totalDays, daysNum: days });
            if (days > maxDays) maxDays = days;
          }
        }

        // Determine gate placement
        let placedGateKey = null;
        let placedGateNumber = '';
        let placedGateName = '';

        if (holdUpper === 'ORDER STOP') {
          placedGateKey = HOLD_KEY;
        } else if (activeOps.length === 0) {
          placedGateKey = HOLD_KEY;
        } else {
          // Walk gatesByPart in CSV order — first qualifying gate wins
          const partGates = gatesByPart[partNo] || [];
          for (const gate of partGates) {
            let found = false;
            for (const gateOper of gate.opers) {
              const nGateOper = normOper(gateOper);
              const mod = modifierByOper[partNo + '|||' + nGateOper] || '';
              if (mod === 'ignore') continue;
              for (const aOp of activeOps) {
                if (normOper(aOp.operNo) === nGateOper) { found = true; break; }
              }
              if (found) break;
            }
            if (found) {
              placedGateKey = gate.gateNumber + '|||' + gate.gateName;
              placedGateNumber = gate.gateNumber;
              placedGateName = gate.gateName;
              break;
            }
          }
          if (!placedGateKey) placedGateKey = HOLD_KEY;
        }

        if (!gateViewBuckets[placedGateKey]) {
          gateViewBuckets[placedGateKey] = {
            gateNumber: placedGateKey === HOLD_KEY ? '' : placedGateNumber,
            gateName: placedGateKey === HOLD_KEY ? 'Hold' : placedGateName,
            isHold: placedGateKey === HOLD_KEY,
            orders: []
          };
        }
        gateViewBuckets[placedGateKey].orders.push({
          orderNo: orderNo, partNo: partNo, serialNo: firstRow.serialNo,
          holdStatus: holdStatus, program: program, maxDays: maxDays, activeOps: activeOps
        });
      }
    }
  }

  // Sort orders within each bucket by maxDays descending (FIFO — highest days on left)
  for (const key of Object.keys(gateViewBuckets)) {
    gateViewBuckets[key].orders.sort(function(a, b) { return b.maxDays - a.maxDays; });
  }

  // Sort gates: Hold first, then ascending gate number
  const gateKeys = Object.keys(gateViewBuckets);
  gateKeys.sort(function(a, b) {
    if (a === HOLD_KEY) return -1;
    if (b === HOLD_KEY) return 1;
    const numA = parseFloat(gateViewBuckets[a].gateNumber) || 0;
    const numB = parseFloat(gateViewBuckets[b].gateNumber) || 0;
    return numA - numB;
  });

  // ==== GATE VIEW: Render ====
  let gvHtml = '<div class="gate-view-wrapper">';
  gvHtml += '<div class="gate-view-title">Gate View</div>';

  for (const gKey of gateKeys) {
    const bucket = gateViewBuckets[gKey];
    const headerText = bucket.isHold
      ? 'Hold (' + bucket.orders.length + ' orders)'
      : bucket.gateNumber + '. ' + bucket.gateName + ' (' + bucket.orders.length + ' orders)';

    gvHtml += '<div class="gv-gate-section">';
    gvHtml += '<div class="gv-gate-header' + (bucket.isHold ? ' hold-gate' : '') + '">' + esc(headerText) + '</div>';
    gvHtml += '<div class="gv-cards-row">';

    for (const order of bucket.orders) {
      const color = programColorMap[order.program] || programColors[0];

      // Build tooltip
      let tip = 'Program: ' + order.program;
      if (order.holdStatus) tip += '\nHold: ' + order.holdStatus;

      // Show total days for the highest-days operation
      let highOp = null;
      for (const aOp of order.activeOps) {
        if (!highOp || aOp.daysNum > highOp.daysNum) highOp = aOp;
      }
      if (highOp) tip += '\nTotal Days: ' + (highOp.totalDays || '0') + ' (Oper ' + highOp.operNo + ')';

      if (order.activeOps.length > 0) {
        tip += '\n\nActive/In Queue Operations:';
        for (const op of order.activeOps) {
          tip += '\n  ' + op.operNo + ' \u2014 ' + op.operTitle + ' \u2014 ' + op.operStatus;
          if (op.workDept) tip += ' \u2014 ' + op.workDept;
        }
      }

      gvHtml += '<div class="gv-order-card" style="background:' + color.bg + ';border-color:' + color.border + ';" title="' + esc(tip) + '">';
      gvHtml += '<div class="gv-order-no">' + esc(order.orderNo) + '</div>';
      gvHtml += '<div class="gv-part-no">' + esc(order.partNo) + '</div>';
      gvHtml += '<div class="gv-sn">S/N: ' + esc(order.serialNo) + '</div>';
      if (order.holdStatus) {
        gvHtml += '<div class="gv-hold">' + esc(order.holdStatus.substring(0, 12)) + '</div>';
      }
      gvHtml += '<div class="gv-days">' + order.maxDays + ' days</div>';
      gvHtml += '</div>';
    }

    gvHtml += '</div></div>';
  }

  gvHtml += '</div>';
  output.insertAdjacentHTML('beforeend', gvHtml);
}

function normOper(s) {
  const n = String(s).replace(/^0+/, '');
  return n === '' ? '0' : n;
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}
</script>
</body>
</html>
